import numpy as np
from pytictoc import TicToc
from SOD_Learn.find_maximums import find_maximums
from SOD_Learn.prepare_hist_items import prepare_hist_items
from SOD_Learn.package_rhoLT import package_rhoLT
from SOD_Utils.partition_traj import partition_traj
from SOD_Learn.package_rhoLT import package_rhoLT

def estimateRhoLT(obs_data, sys_info, obs_info):
    # function rhoLT = estimateRhoLT(obs_data, sys_info, obs_info)
    #
    # finds the discretized rho_LT in three different categorizes
    # IN: usual structures defining the system; the simulations used to construct the estimator
    #     for \rho_L^T are obs_data.x
    #       [obs_info.Rsupp]  : if provided and with nonempty .R, it is used as initial 
    #                           guess for the support of the histograms of various estimated \rho_L^T's. 
    #                           Should contain the fields R, dotR, xiR, each of which is a sys_info.K by 
    #                           sys_info.K cell, with each cell contains a 2-vector determining an interval
    #                           which are generated by the system
    # OUT:
    #   rhoLT:   struct containining three different rhoLTs: rhoLTE, rhoLTA, rhoLTXi
    #   rhoLTE:  struct containing empirical estimator of \rho_L^T for energy based interactions
    #     histcount{k_1,k_2}  : histogram count estimator for type (k_1,k_2) of pairwise distance r
    #     hist{k_1,k_2}       : probability-normalized histogram of histcount{k_1,k_2}
    #     supp{k_1,k_2}       : estimated support for r for histcount{k_1,k_2}
    #     histedges{k_1, k_2} : bins of r that generate histcount{k_1,k_2}
    #   rhoLTA:  struct containing empirical estimator of \rho_L^T for alignment based interactions
    #     histcount{k_1,k_2}  : histogram count estimator for type (k_1,k_2) of pairwise distance r and |\bv_i - \bv_{i'}|
    #     hist{k_1,k_2}       : probability-normalized histogram of histcount{k_1,k_2}
    #     supp{k_1,k_2}       : estimated support of r |\bv_i - \bv_{i'}| and for histcount{k_1,k_2}
    #     histedges{k_1, k_2} : bins of r |\bv_i - \bv_{i'}| that generate histcount{k_1,k_2}
    #     rhoTR               : marginal distribution of r, has the 4 fields as in rhoLTE
    #     rhoTDR              : marginal distribution of \dot{r}, has the 4 fields as in rhoLTE
    #   rhoLTXi: struct containing empirical estimator of \rho_L^T for xi based interactions
    #     histcount{k_1,k_2}  : histogram count estimator for type (k_1,k_2) of pairwise distance r and |\xi_i - \xi_{i'}|
    #     hist{k_1,k_2}       : probability-normalized histogram of histcount{k_1,k_2}
    #     supp{k_1,k_2}       : estimated support of r and |\xi_i - \xi_{i'}| for histcount{k_1,k_2}
    #     histedges{k_1, k_2} : bins of r and |\xi_i - \xi_{i'}| that generate histcount{k_1,k_2}
    #     rhoTR               : marginal distribution of r, has the 4 fields as in rhoLTE
    #     mrhoLTXi             : marginal distribution of \xi, has the 4 fields as in rhoLTE

    # (c) M. Zhong (JHU)

    Timings = {}
    t=TicToc()
    Timings['total'] = t.tic()

    # prepare some indicators
    if sys_info['ode_order'] == 1:
        has_align = False
        has_xi = False
    elif sys_info['ode_order'] == 2:
        has_align = bool(sys_info['phiA'])
        has_xi = sys_info['has_xi']
    

    # initialize storage
    #Change shape to 1 for time being
    max_rs = np.zeros((sys_info['K'], sys_info['K'], obs_data['x'].shape[2]))
    min_rs = np.zeros((sys_info['K'], sys_info['K'], obs_data['x'].shape[2]))
    max_dotrs=None
    min_dotrs = None
    max_xis = None
    min_xis = None

    if has_align:
        max_dotrs = np.zeros((sys_info['K'], sys_info['K'], obs_data['x'].shape[2]))
        min_dotrs = np.zeros((sys_info['K'], sys_info['K'], obs_data['x'].shape[2]))

    if has_xi:
        max_xis = np.zeros((sys_info['K'], sys_info['K'], obs_data['x'].shape[2]))
        min_xis = np.zeros((sys_info['K'], sys_info['K'], obs_data['x'].shape[2]))

    # use the max_rs, max_dotrs and max_xis from user input if given
    if 'max_rs' in obs_info and obs_info['max_rs'] is not None:
        max_rs = obs_info['max_rs']
        if has_align:
            max_dotrs = obs_info['max_dotrs']
        if has_xi:
            max_xis = obs_info['max_xis']
    else:
        Mtrajs = obs_data['x']
        for m in range(obs_data['x'].shape[2]):
            traj = np.squeeze(Mtrajs[:, :, m])
            output = find_maximums(traj, sys_info)
            max_rs[:, :, m] = output['max_rs']
            if has_align:
                max_dotrs[:, :, m] = output['max_dotrs']
            if has_xi:
                max_xis[:, :, m] = output['max_xis']

        # find out the maximum over all m realizations
        #print('Max rs size from find_maximum')
        #print(max_rs.shape)
        max_rs = np.max(max_rs, axis=2,keepdims=True)
        if has_align:
            max_dotrs = np.max(max_dotrs, axis=2,keepdims=True)
        if has_xi:
            max_xis = np.max(max_xis, axis=2,keepdims=True)

    # prepare the bins for hist count
    (
        histedgesR,
        histbinwidthR,
        histedgesDR,
        histbinwidthDR,
        histedgesXi,
        histbinwidthXi,
        histcountR,
        histcountA,
        histcountDR,
        jhistcountXi,
        histcountXi
    ) = prepare_hist_items(sys_info['K'], obs_info['hist_num_bins'], obs_data['x'].shape[2], max_rs, max_dotrs, max_xis)

    # go through each MC realization
    histcountR = []
    histcountA = []
    histcountDR = []
    jhistcountXi = []
    histcountXi = []
    #print('from Estimate')
    #print(max_rs.shape)
    max_rs = np.zeros((max_rs.shape[0], max_rs.shape[1], Mtrajs.shape[2]))
    for m in range(Mtrajs.shape[2]):
        traj = np.squeeze(Mtrajs[:, :, m])
        pdist_out = partition_traj(traj, sys_info)
        max_rs[:,:, m] = pdist_out['max_r']
        min_rs[:,:, m] = pdist_out['min_r']
        histcountR_m = {}
        histcountA_m = {}
        histcountDR_m = {}
        jhistcountXi_m = {}
        histcountXi_m = {}

        for k1 in range(sys_info['K']):
            for k2 in range(sys_info['K']):
                pdist_x_Ck1_Ck2 = pdist_out['pdist_x'][k1][k2]
                #print(pdist_x_Ck1_Ck2)

                if pdist_x_Ck1_Ck2 is not None and  pdist_x_Ck1_Ck2.size > 0:
                    #print((histedgesR[k1][k2]).ravel())
                    histcountR_m[(k1, k2)] = np.histogram(pdist_x_Ck1_Ck2.flatten(), bins=(histedgesR[k1][k2]).ravel(), density=False)[0]
                    #histcountR_m[(k1, k2)], histedgesR[k1][k2] = np.histogram(pdist_x_Ck1_Ck2.flatten(), bins=obs_info['hist_num_bins'], density=False)
                    #histbinwidthR[k1][k2] = np.max(histedgesR[k1][k2])/obs_info['hist_num_bins']
                else:
                    histcountR_m[(k1, k2)]=None

                if has_align:
                    pdist_v_Ck1_Ck2 = pdist_out['pdist_v'][k1][k2]

                    if pdist_v_Ck1_Ck2.size > 0 and pdist_x_Ck1_Ck2.size > 0:
                        histcountA_m[(k1, k2)] = np.histogram2d(
                            pdist_x_Ck1_Ck2.flatten(),
                            pdist_v_Ck1_Ck2.flatten(),
                            bins=(histedgesR[k1,k2], histedgesDR[(k1, k2)]),
                            density=False
                        )[0]
                        histcountDR_m[(k1, k2)] = np.histogram(pdist_v_Ck1_Ck2.flatten(), bins=histedgesDR[(k1, k2)], density=False)[0]

                if has_xi:
                    pdist_xi_Ck1_Ck2 = pdist_out['pdist_xi'][k1][k2]

                    if pdist_xi_Ck1_Ck2.size > 0 and pdist_x_Ck1_Ck2.size > 0:
                        histcountXi_m[(k1, k2)] = np.histogram2d(
                            pdist_x_Ck1_Ck2.flatten(),
                            pdist_xi_Ck1_Ck2.flatten(),
                            bins=(histedgesR[k1,k2], histedgesXi[(k1, k2)]),
                            density=False
                        )[0]
                        histcountXi_m[(k1, k2)] = np.histogram(pdist_xi_Ck1_Ck2.flatten(), bins=histedgesXi[(k1, k2)], density=False)[0]

        histcountR.append(histcountR_m)
        if has_align:
            histcountA.append(histcountA_m)
            histcountDR.append(histcountDR_m)
        if has_xi:
            jhistcountXi.append(jhistcountXi_m)
            histcountXi.append(histcountXi_m)
    #print('From Estimate RholT.....')
    #print(histcountR)
    # package the data
    rhoLT = package_rhoLT(
        histedgesR,
        histcountR,
        histbinwidthR,
        histedgesDR,
        histcountDR,
        histbinwidthDR,
        histedgesXi,
        histcountXi,
        histbinwidthXi,
        histcountA,
        jhistcountXi,
        Mtrajs.shape[2],
        sys_info,
        obs_info,
        max_rs,
        min_rs,
        max_dotrs,
        min_dotrs,
        max_xis,
        min_xis
    )
    rhoLT['Timings'] = {'total': t.toc(Timings['total'])}
    return rhoLT
